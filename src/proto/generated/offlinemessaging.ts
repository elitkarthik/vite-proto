// @generated by protobuf-ts 2.9.6
// @generated from protobuf file "offlinemessaging.proto" (package "offlineMessaging", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
// ----------------------------
// offline data models
// ----------------------------

/**
 * @generated from protobuf message offlineMessaging.OfflineMessageHeader
 */
export interface OfflineMessageHeader {
    /**
     * @generated from protobuf field: int32 institutionID = 1;
     */
    institutionID: number;
    /**
     * @generated from protobuf field: int32 branchID = 2;
     */
    branchID: number;
    /**
     * @generated from protobuf field: string userID = 3;
     */
    userID: string;
}
/**
 * @generated from protobuf message offlineMessaging.OfflineResponse
 */
export interface OfflineResponse {
    /**
     * @generated from protobuf field: offlineMessaging.OfflineMessageHeader messageHeader = 1;
     */
    messageHeader?: OfflineMessageHeader;
    /**
     * @generated from protobuf field: string status = 2;
     */
    status: string;
    /**
     * @generated from protobuf field: string statusMessage = 3;
     */
    statusMessage: string;
}
/**
 * @generated from protobuf message offlineMessaging.CachedParameterItem
 */
export interface CachedParameterItem {
    /**
     * @generated from protobuf field: offlineMessaging.OfflineMessageHeader header = 1;
     */
    header?: OfflineMessageHeader;
    /**
     * @generated from protobuf field: string parameterType = 2;
     */
    parameterType: string;
    /**
     * @generated from protobuf field: string parameterValue = 3;
     */
    parameterValue: string;
    /**
     * @generated from protobuf field: string endpointURI = 4;
     */
    endpointURI: string;
    /**
     * @generated from protobuf field: string dateAdded = 5;
     */
    dateAdded: string;
    /**
     * @generated from protobuf field: string expirationDate = 6;
     */
    expirationDate: string;
}
/**
 * @generated from protobuf message offlineMessaging.CachedTransactionItem
 */
export interface CachedTransactionItem {
    /**
     * @generated from protobuf field: offlineMessaging.OfflineMessageHeader header = 1;
     */
    header?: OfflineMessageHeader;
    /**
     * @generated from protobuf field: string processingDate = 2;
     */
    processingDate: string;
    /**
     * @generated from protobuf field: string endpointURI = 3;
     */
    endpointURI: string;
    /**
     * @generated from protobuf field: string payloadType = 4;
     */
    payloadType: string;
    /**
     * @generated from protobuf field: string payload = 5;
     */
    payload: string;
    /**
     * @generated from protobuf field: string lastResult = 7;
     */
    lastResult: string;
    /**
     * @generated from protobuf field: string lastSendAttempt = 8;
     */
    lastSendAttempt: string;
    /**
     * @generated from protobuf field: int32 sendAttempts = 9;
     */
    sendAttempts: number;
    /**
     * @generated from protobuf field: string dateAdded = 10;
     */
    dateAdded: string;
    /**
     * @generated from protobuf field: string expirationDate = 11;
     */
    expirationDate: string;
    /**
     * @generated from protobuf field: int32 rowID = 12;
     */
    rowID: number;
}
/**
 * @generated from protobuf message offlineMessaging.CachedResponseItem
 */
export interface CachedResponseItem {
    /**
     * @generated from protobuf field: offlineMessaging.CachedTransactionItem transactionInfo = 1;
     */
    transactionInfo?: CachedTransactionItem;
    /**
     * @generated from protobuf field: string responsePayload = 2;
     */
    responsePayload: string;
}
/**
 * @generated from protobuf message offlineMessaging.UserSettingsItem
 */
export interface UserSettingsItem {
    /**
     * @generated from protobuf field: offlineMessaging.OfflineMessageHeader header = 1;
     */
    header?: OfflineMessageHeader;
    /**
     * @generated from protobuf field: string instanceName = 2;
     */
    instanceName: string;
    /**
     * @generated from protobuf field: string settingKey = 3;
     */
    settingKey: string;
    /**
     * @generated from protobuf field: string setting = 4;
     */
    setting: string;
}
/**
 * @generated from protobuf message offlineMessaging.OfflineLoggingItem
 */
export interface OfflineLoggingItem {
    /**
     * @generated from protobuf field: offlineMessaging.OfflineMessageHeader header = 1;
     */
    header?: OfflineMessageHeader;
    /**
     * @generated from protobuf field: string methodName = 2;
     */
    methodName: string;
    /**
     * @generated from protobuf field: string logMessage = 3;
     */
    logMessage: string;
    /**
     * @generated from protobuf field: string dateAdded = 4;
     */
    dateAdded: string;
    /**
     * @generated from protobuf field: string expirationDate = 5;
     */
    expirationDate: string;
}
// ----------------------------

/**
 * ----------------------------
 * Offline parameter messages
 * ----------------------------
 *
 * @generated from protobuf message offlineMessaging.GetOfflineParameterDataRequest
 */
export interface GetOfflineParameterDataRequest {
    /**
     * @generated from protobuf field: offlineMessaging.OfflineMessageHeader messageHeader = 1;
     */
    messageHeader?: OfflineMessageHeader;
    /**
     * @generated from protobuf field: string payloadType = 2;
     */
    payloadType: string;
}
/**
 * @generated from protobuf message offlineMessaging.GetOfflineParameterDataResponse
 */
export interface GetOfflineParameterDataResponse {
    /**
     * @generated from protobuf field: offlineMessaging.OfflineResponse responseStatus = 1;
     */
    responseStatus?: OfflineResponse;
    /**
     * @generated from protobuf field: repeated offlineMessaging.CachedParameterItem parameters = 2;
     */
    parameters: CachedParameterItem[];
}
/**
 * @generated from protobuf message offlineMessaging.SaveOfflineParameterRequest
 */
export interface SaveOfflineParameterRequest {
    /**
     * @generated from protobuf field: offlineMessaging.OfflineMessageHeader messageHeader = 1;
     */
    messageHeader?: OfflineMessageHeader;
    /**
     * @generated from protobuf field: string payloadType = 2;
     */
    payloadType: string;
    /**
     * @generated from protobuf field: string payload = 3;
     */
    payload: string;
    /**
     * @generated from protobuf field: string enpoint = 4;
     */
    enpoint: string;
    /**
     * @generated from protobuf field: int32 expiresIn = 5;
     */
    expiresIn: number;
    /**
     * @generated from protobuf field: string expirationUnit = 6;
     */
    expirationUnit: string;
}
/**
 * @generated from protobuf message offlineMessaging.DeleteOfflineParameterRequest
 */
export interface DeleteOfflineParameterRequest {
    /**
     * @generated from protobuf field: offlineMessaging.OfflineMessageHeader messageHeader = 1;
     */
    messageHeader?: OfflineMessageHeader;
    /**
     * @generated from protobuf field: string payloadType = 2;
     */
    payloadType: string;
}
/**
 * -----------------------------
 * Offline transaction messages
 * -----------------------------
 *
 * @generated from protobuf message offlineMessaging.GetOfflineTransactionDataRequest
 */
export interface GetOfflineTransactionDataRequest {
    /**
     * @generated from protobuf field: offlineMessaging.OfflineMessageHeader messageHeader = 1;
     */
    messageHeader?: OfflineMessageHeader;
    /**
     * @generated from protobuf field: string payloadType = 2;
     */
    payloadType: string;
    /**
     * @generated from protobuf field: string processingDate = 3;
     */
    processingDate: string;
}
/**
 * @generated from protobuf message offlineMessaging.GetOfflineTransactionDataResponse
 */
export interface GetOfflineTransactionDataResponse {
    /**
     * @generated from protobuf field: offlineMessaging.OfflineResponse responseStatus = 1;
     */
    responseStatus?: OfflineResponse;
    /**
     * @generated from protobuf field: repeated offlineMessaging.CachedTransactionItem transactions = 2;
     */
    transactions: CachedTransactionItem[];
}
/**
 * @generated from protobuf message offlineMessaging.SaveOfflineTransactionReqeust
 */
export interface SaveOfflineTransactionReqeust {
    /**
     * @generated from protobuf field: offlineMessaging.OfflineMessageHeader messageHeader = 1;
     */
    messageHeader?: OfflineMessageHeader;
    /**
     * @generated from protobuf field: string processingDate = 2;
     */
    processingDate: string;
    /**
     * @generated from protobuf field: string payloadType = 3;
     */
    payloadType: string;
    /**
     * @generated from protobuf field: string payload = 4;
     */
    payload: string;
    /**
     * @generated from protobuf field: string enpoint = 5;
     */
    enpoint: string;
    /**
     * @generated from protobuf field: string sendResult = 6;
     */
    sendResult: string;
    /**
     * @generated from protobuf field: string lastSendAttempt = 7;
     */
    lastSendAttempt: string;
}
/**
 * @generated from protobuf message offlineMessaging.DeleteOfflineTransactionRequest
 */
export interface DeleteOfflineTransactionRequest {
    /**
     * @generated from protobuf field: offlineMessaging.OfflineMessageHeader messageHeader = 1;
     */
    messageHeader?: OfflineMessageHeader;
    /**
     * @generated from protobuf field: string payloadType = 2;
     */
    payloadType: string;
    /**
     * @generated from protobuf field: string processingDate = 3;
     */
    processingDate: string;
    /**
     * @generated from protobuf field: string dateAdded = 4;
     */
    dateAdded: string;
    /**
     * @generated from protobuf field: int32 rowID = 5;
     */
    rowID: number;
}
/**
 * ------------------------------
 * Cached response information
 * ------------------------------
 *
 * @generated from protobuf message offlineMessaging.GetCachedResponsesRequest
 */
export interface GetCachedResponsesRequest {
    /**
     * @generated from protobuf field: offlineMessaging.OfflineMessageHeader messageHeader = 1;
     */
    messageHeader?: OfflineMessageHeader;
    /**
     * @generated from protobuf field: string processingDate = 2;
     */
    processingDate: string;
    /**
     * @generated from protobuf field: string payloadType = 3;
     */
    payloadType: string;
}
/**
 * @generated from protobuf message offlineMessaging.GetCachedResponsesResponse
 */
export interface GetCachedResponsesResponse {
    /**
     * @generated from protobuf field: offlineMessaging.OfflineResponse responseStatus = 1;
     */
    responseStatus?: OfflineResponse;
    /**
     * @generated from protobuf field: repeated offlineMessaging.CachedResponseItem cachedResponses = 2;
     */
    cachedResponses: CachedResponseItem[];
}
/**
 * @generated from protobuf message offlineMessaging.SaveCachedResponseRequest
 */
export interface SaveCachedResponseRequest {
    /**
     * @generated from protobuf field: offlineMessaging.CachedResponseItem responseItem = 2;
     */
    responseItem?: CachedResponseItem;
}
/**
 * @generated from protobuf message offlineMessaging.DeleteCachedResponseRequest
 */
export interface DeleteCachedResponseRequest {
    /**
     * @generated from protobuf field: offlineMessaging.OfflineMessageHeader messageHeader = 1;
     */
    messageHeader?: OfflineMessageHeader;
    /**
     * @generated from protobuf field: string payloadType = 2;
     */
    payloadType: string;
    /**
     * @generated from protobuf field: string processingDate = 3;
     */
    processingDate: string;
    /**
     * @generated from protobuf field: string dateAdded = 4;
     */
    dateAdded: string;
    /**
     * @generated from protobuf field: string responsePayload = 5;
     */
    responsePayload: string;
}
/**
 * -------------------------------
 * Deadletter Queue items
 * -------------------------------
 *
 * @generated from protobuf message offlineMessaging.GetDeadletterQueueDataRequest
 */
export interface GetDeadletterQueueDataRequest {
    /**
     * @generated from protobuf field: offlineMessaging.OfflineMessageHeader messageHeader = 1;
     */
    messageHeader?: OfflineMessageHeader;
    /**
     * @generated from protobuf field: string payloadType = 2;
     */
    payloadType: string;
    /**
     * @generated from protobuf field: string processingDate = 3;
     */
    processingDate: string;
    /**
     * @generated from protobuf field: string dateAdded = 4;
     */
    dateAdded: string;
}
/**
 * @generated from protobuf message offlineMessaging.GetDeadletterQueueDataResponse
 */
export interface GetDeadletterQueueDataResponse {
    /**
     * @generated from protobuf field: offlineMessaging.OfflineResponse responseStatus = 1;
     */
    responseStatus?: OfflineResponse;
    /**
     * @generated from protobuf field: repeated offlineMessaging.CachedTransactionItem deadletterItems = 2;
     */
    deadletterItems: CachedTransactionItem[];
}
/**
 * @generated from protobuf message offlineMessaging.SaveDeadletterQueueDataRequest
 */
export interface SaveDeadletterQueueDataRequest {
    /**
     * @generated from protobuf field: offlineMessaging.CachedTransactionItem transactionItem = 1;
     */
    transactionItem?: CachedTransactionItem;
    /**
     * @generated from protobuf field: string deadLetterExpiration = 2;
     */
    deadLetterExpiration: string;
}
/**
 * @generated from protobuf message offlineMessaging.SaveDeadletterQueueDataResponse
 */
export interface SaveDeadletterQueueDataResponse {
    /**
     * @generated from protobuf field: offlineMessaging.OfflineResponse responseStatus = 1;
     */
    responseStatus?: OfflineResponse;
    /**
     * @generated from protobuf field: offlineMessaging.CachedTransactionItem transactionItem = 2;
     */
    transactionItem?: CachedTransactionItem;
}
/**
 * @generated from protobuf message offlineMessaging.DeleteDeadletterQueueDataRequest
 */
export interface DeleteDeadletterQueueDataRequest {
    /**
     * @generated from protobuf field: offlineMessaging.OfflineMessageHeader messageHeader = 1;
     */
    messageHeader?: OfflineMessageHeader;
    /**
     * @generated from protobuf field: string payloadType = 2;
     */
    payloadType: string;
    /**
     * @generated from protobuf field: string processingDate = 3;
     */
    processingDate: string;
    /**
     * @generated from protobuf field: string dateAdded = 4;
     */
    dateAdded: string;
    /**
     * @generated from protobuf field: int32 rowID = 5;
     */
    rowID: number;
}
/**
 * -------------------------------
 * User settings
 * -------------------------------
 *
 * @generated from protobuf message offlineMessaging.GetUserSettingsRequest
 */
export interface GetUserSettingsRequest {
    /**
     * @generated from protobuf field: offlineMessaging.OfflineMessageHeader messageHeader = 1;
     */
    messageHeader?: OfflineMessageHeader;
    /**
     * @generated from protobuf field: string instanceName = 2;
     */
    instanceName: string;
    /**
     * @generated from protobuf field: string settingKey = 3;
     */
    settingKey: string;
}
/**
 * @generated from protobuf message offlineMessaging.GetUserSettingsResponse
 */
export interface GetUserSettingsResponse {
    /**
     * @generated from protobuf field: offlineMessaging.OfflineResponse responseStatus = 1;
     */
    responseStatus?: OfflineResponse;
    /**
     * @generated from protobuf field: repeated offlineMessaging.UserSettingsItem userSettings = 2;
     */
    userSettings: UserSettingsItem[];
}
/**
 * @generated from protobuf message offlineMessaging.SaveUserSettingsRequest
 */
export interface SaveUserSettingsRequest {
    /**
     * @generated from protobuf field: offlineMessaging.OfflineMessageHeader messageHeader = 1;
     */
    messageHeader?: OfflineMessageHeader;
    /**
     * @generated from protobuf field: string instanceName = 2;
     */
    instanceName: string;
    /**
     * @generated from protobuf field: string settingKey = 3;
     */
    settingKey: string;
    /**
     * @generated from protobuf field: string setting = 4;
     */
    setting: string;
}
/**
 * @generated from protobuf message offlineMessaging.DeleteUserSettingRequest
 */
export interface DeleteUserSettingRequest {
    /**
     * @generated from protobuf field: offlineMessaging.OfflineMessageHeader messageHeader = 1;
     */
    messageHeader?: OfflineMessageHeader;
    /**
     * @generated from protobuf field: string instanceName = 2;
     */
    instanceName: string;
    /**
     * @generated from protobuf field: string settingKey = 3;
     */
    settingKey: string;
}
/**
 * ------------------------------
 * Logging user on/off and tracking tokens
 * ------------------------------
 *
 * @generated from protobuf message offlineMessaging.LogonUserRequest
 */
export interface LogonUserRequest {
    /**
     * @generated from protobuf field: offlineMessaging.OfflineMessageHeader messageHeader = 1;
     */
    messageHeader?: OfflineMessageHeader;
    /**
     * @generated from protobuf field: string userToken = 2;
     */
    userToken: string;
    /**
     * @generated from protobuf field: string tokenExpiration = 3;
     */
    tokenExpiration: string;
}
/**
 * @generated from protobuf message offlineMessaging.LogOffUserRequest
 */
export interface LogOffUserRequest {
    /**
     * @generated from protobuf field: offlineMessaging.OfflineMessageHeader messageHeader = 1;
     */
    messageHeader?: OfflineMessageHeader;
}
/**
 * -----------------------------
 * Getting workstation name
 * -----------------------------
 *
 * @generated from protobuf message offlineMessaging.GetWorkstationNameRequest
 */
export interface GetWorkstationNameRequest {
    /**
     * @generated from protobuf field: string workstationID = 1;
     */
    workstationID: string;
}
/**
 * @generated from protobuf message offlineMessaging.GetWorkstationNameResponse
 */
export interface GetWorkstationNameResponse {
    /**
     * @generated from protobuf field: string workstationID = 1;
     */
    workstationID: string;
}
/**
 * ------------------------------
 * Get offline log items
 * ------------------------------
 *
 * @generated from protobuf message offlineMessaging.GetOfflineLogItemsRequest
 */
export interface GetOfflineLogItemsRequest {
    /**
     * @generated from protobuf field: offlineMessaging.OfflineMessageHeader messageHeader = 1;
     */
    messageHeader?: OfflineMessageHeader;
}
/**
 * @generated from protobuf message offlineMessaging.GetOfflineLogItemsResponse
 */
export interface GetOfflineLogItemsResponse {
    /**
     * @generated from protobuf field: offlineMessaging.OfflineResponse responseStatus = 1;
     */
    responseStatus?: OfflineResponse;
    /**
     * @generated from protobuf field: repeated offlineMessaging.OfflineLoggingItem LogItems = 2 [json_name = "LogItems"];
     */
    logItems: OfflineLoggingItem[];
}
/**
 * @generated from protobuf message offlineMessaging.SaveOfflineLogItemRequest
 */
export interface SaveOfflineLogItemRequest {
    /**
     * @generated from protobuf field: offlineMessaging.OfflineLoggingItem logItem = 1;
     */
    logItem?: OfflineLoggingItem;
}
// @generated message type with reflection information, may provide speed optimized methods
class OfflineMessageHeader$Type extends MessageType<OfflineMessageHeader> {
    constructor() {
        super("offlineMessaging.OfflineMessageHeader", [
            { no: 1, name: "institutionID", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "branchID", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "userID", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OfflineMessageHeader>): OfflineMessageHeader {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.institutionID = 0;
        message.branchID = 0;
        message.userID = "";
        if (value !== undefined)
            reflectionMergePartial<OfflineMessageHeader>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OfflineMessageHeader): OfflineMessageHeader {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 institutionID */ 1:
                    message.institutionID = reader.int32();
                    break;
                case /* int32 branchID */ 2:
                    message.branchID = reader.int32();
                    break;
                case /* string userID */ 3:
                    message.userID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OfflineMessageHeader, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 institutionID = 1; */
        if (message.institutionID !== 0)
            writer.tag(1, WireType.Varint).int32(message.institutionID);
        /* int32 branchID = 2; */
        if (message.branchID !== 0)
            writer.tag(2, WireType.Varint).int32(message.branchID);
        /* string userID = 3; */
        if (message.userID !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.userID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.OfflineMessageHeader
 */
export const OfflineMessageHeader = new OfflineMessageHeader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OfflineResponse$Type extends MessageType<OfflineResponse> {
    constructor() {
        super("offlineMessaging.OfflineResponse", [
            { no: 1, name: "messageHeader", kind: "message", T: () => OfflineMessageHeader },
            { no: 2, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "statusMessage", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OfflineResponse>): OfflineResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = "";
        message.statusMessage = "";
        if (value !== undefined)
            reflectionMergePartial<OfflineResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OfflineResponse): OfflineResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.OfflineMessageHeader messageHeader */ 1:
                    message.messageHeader = OfflineMessageHeader.internalBinaryRead(reader, reader.uint32(), options, message.messageHeader);
                    break;
                case /* string status */ 2:
                    message.status = reader.string();
                    break;
                case /* string statusMessage */ 3:
                    message.statusMessage = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OfflineResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.OfflineMessageHeader messageHeader = 1; */
        if (message.messageHeader)
            OfflineMessageHeader.internalBinaryWrite(message.messageHeader, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string status = 2; */
        if (message.status !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.status);
        /* string statusMessage = 3; */
        if (message.statusMessage !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.statusMessage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.OfflineResponse
 */
export const OfflineResponse = new OfflineResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CachedParameterItem$Type extends MessageType<CachedParameterItem> {
    constructor() {
        super("offlineMessaging.CachedParameterItem", [
            { no: 1, name: "header", kind: "message", T: () => OfflineMessageHeader },
            { no: 2, name: "parameterType", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "parameterValue", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "endpointURI", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "dateAdded", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "expirationDate", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CachedParameterItem>): CachedParameterItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.parameterType = "";
        message.parameterValue = "";
        message.endpointURI = "";
        message.dateAdded = "";
        message.expirationDate = "";
        if (value !== undefined)
            reflectionMergePartial<CachedParameterItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CachedParameterItem): CachedParameterItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.OfflineMessageHeader header */ 1:
                    message.header = OfflineMessageHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* string parameterType */ 2:
                    message.parameterType = reader.string();
                    break;
                case /* string parameterValue */ 3:
                    message.parameterValue = reader.string();
                    break;
                case /* string endpointURI */ 4:
                    message.endpointURI = reader.string();
                    break;
                case /* string dateAdded */ 5:
                    message.dateAdded = reader.string();
                    break;
                case /* string expirationDate */ 6:
                    message.expirationDate = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CachedParameterItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.OfflineMessageHeader header = 1; */
        if (message.header)
            OfflineMessageHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string parameterType = 2; */
        if (message.parameterType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.parameterType);
        /* string parameterValue = 3; */
        if (message.parameterValue !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.parameterValue);
        /* string endpointURI = 4; */
        if (message.endpointURI !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.endpointURI);
        /* string dateAdded = 5; */
        if (message.dateAdded !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.dateAdded);
        /* string expirationDate = 6; */
        if (message.expirationDate !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.expirationDate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.CachedParameterItem
 */
export const CachedParameterItem = new CachedParameterItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CachedTransactionItem$Type extends MessageType<CachedTransactionItem> {
    constructor() {
        super("offlineMessaging.CachedTransactionItem", [
            { no: 1, name: "header", kind: "message", T: () => OfflineMessageHeader },
            { no: 2, name: "processingDate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "endpointURI", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "payloadType", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "payload", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "lastResult", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "lastSendAttempt", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "sendAttempts", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "dateAdded", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "expirationDate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "rowID", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CachedTransactionItem>): CachedTransactionItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.processingDate = "";
        message.endpointURI = "";
        message.payloadType = "";
        message.payload = "";
        message.lastResult = "";
        message.lastSendAttempt = "";
        message.sendAttempts = 0;
        message.dateAdded = "";
        message.expirationDate = "";
        message.rowID = 0;
        if (value !== undefined)
            reflectionMergePartial<CachedTransactionItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CachedTransactionItem): CachedTransactionItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.OfflineMessageHeader header */ 1:
                    message.header = OfflineMessageHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* string processingDate */ 2:
                    message.processingDate = reader.string();
                    break;
                case /* string endpointURI */ 3:
                    message.endpointURI = reader.string();
                    break;
                case /* string payloadType */ 4:
                    message.payloadType = reader.string();
                    break;
                case /* string payload */ 5:
                    message.payload = reader.string();
                    break;
                case /* string lastResult */ 7:
                    message.lastResult = reader.string();
                    break;
                case /* string lastSendAttempt */ 8:
                    message.lastSendAttempt = reader.string();
                    break;
                case /* int32 sendAttempts */ 9:
                    message.sendAttempts = reader.int32();
                    break;
                case /* string dateAdded */ 10:
                    message.dateAdded = reader.string();
                    break;
                case /* string expirationDate */ 11:
                    message.expirationDate = reader.string();
                    break;
                case /* int32 rowID */ 12:
                    message.rowID = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CachedTransactionItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.OfflineMessageHeader header = 1; */
        if (message.header)
            OfflineMessageHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string processingDate = 2; */
        if (message.processingDate !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.processingDate);
        /* string endpointURI = 3; */
        if (message.endpointURI !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.endpointURI);
        /* string payloadType = 4; */
        if (message.payloadType !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.payloadType);
        /* string payload = 5; */
        if (message.payload !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.payload);
        /* string lastResult = 7; */
        if (message.lastResult !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.lastResult);
        /* string lastSendAttempt = 8; */
        if (message.lastSendAttempt !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.lastSendAttempt);
        /* int32 sendAttempts = 9; */
        if (message.sendAttempts !== 0)
            writer.tag(9, WireType.Varint).int32(message.sendAttempts);
        /* string dateAdded = 10; */
        if (message.dateAdded !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.dateAdded);
        /* string expirationDate = 11; */
        if (message.expirationDate !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.expirationDate);
        /* int32 rowID = 12; */
        if (message.rowID !== 0)
            writer.tag(12, WireType.Varint).int32(message.rowID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.CachedTransactionItem
 */
export const CachedTransactionItem = new CachedTransactionItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CachedResponseItem$Type extends MessageType<CachedResponseItem> {
    constructor() {
        super("offlineMessaging.CachedResponseItem", [
            { no: 1, name: "transactionInfo", kind: "message", T: () => CachedTransactionItem },
            { no: 2, name: "responsePayload", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CachedResponseItem>): CachedResponseItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.responsePayload = "";
        if (value !== undefined)
            reflectionMergePartial<CachedResponseItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CachedResponseItem): CachedResponseItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.CachedTransactionItem transactionInfo */ 1:
                    message.transactionInfo = CachedTransactionItem.internalBinaryRead(reader, reader.uint32(), options, message.transactionInfo);
                    break;
                case /* string responsePayload */ 2:
                    message.responsePayload = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CachedResponseItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.CachedTransactionItem transactionInfo = 1; */
        if (message.transactionInfo)
            CachedTransactionItem.internalBinaryWrite(message.transactionInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string responsePayload = 2; */
        if (message.responsePayload !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.responsePayload);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.CachedResponseItem
 */
export const CachedResponseItem = new CachedResponseItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserSettingsItem$Type extends MessageType<UserSettingsItem> {
    constructor() {
        super("offlineMessaging.UserSettingsItem", [
            { no: 1, name: "header", kind: "message", T: () => OfflineMessageHeader },
            { no: 2, name: "instanceName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "settingKey", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "setting", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserSettingsItem>): UserSettingsItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.instanceName = "";
        message.settingKey = "";
        message.setting = "";
        if (value !== undefined)
            reflectionMergePartial<UserSettingsItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserSettingsItem): UserSettingsItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.OfflineMessageHeader header */ 1:
                    message.header = OfflineMessageHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* string instanceName */ 2:
                    message.instanceName = reader.string();
                    break;
                case /* string settingKey */ 3:
                    message.settingKey = reader.string();
                    break;
                case /* string setting */ 4:
                    message.setting = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserSettingsItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.OfflineMessageHeader header = 1; */
        if (message.header)
            OfflineMessageHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string instanceName = 2; */
        if (message.instanceName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.instanceName);
        /* string settingKey = 3; */
        if (message.settingKey !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.settingKey);
        /* string setting = 4; */
        if (message.setting !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.setting);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.UserSettingsItem
 */
export const UserSettingsItem = new UserSettingsItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OfflineLoggingItem$Type extends MessageType<OfflineLoggingItem> {
    constructor() {
        super("offlineMessaging.OfflineLoggingItem", [
            { no: 1, name: "header", kind: "message", T: () => OfflineMessageHeader },
            { no: 2, name: "methodName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "logMessage", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "dateAdded", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "expirationDate", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OfflineLoggingItem>): OfflineLoggingItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.methodName = "";
        message.logMessage = "";
        message.dateAdded = "";
        message.expirationDate = "";
        if (value !== undefined)
            reflectionMergePartial<OfflineLoggingItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OfflineLoggingItem): OfflineLoggingItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.OfflineMessageHeader header */ 1:
                    message.header = OfflineMessageHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* string methodName */ 2:
                    message.methodName = reader.string();
                    break;
                case /* string logMessage */ 3:
                    message.logMessage = reader.string();
                    break;
                case /* string dateAdded */ 4:
                    message.dateAdded = reader.string();
                    break;
                case /* string expirationDate */ 5:
                    message.expirationDate = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OfflineLoggingItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.OfflineMessageHeader header = 1; */
        if (message.header)
            OfflineMessageHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string methodName = 2; */
        if (message.methodName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.methodName);
        /* string logMessage = 3; */
        if (message.logMessage !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.logMessage);
        /* string dateAdded = 4; */
        if (message.dateAdded !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.dateAdded);
        /* string expirationDate = 5; */
        if (message.expirationDate !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.expirationDate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.OfflineLoggingItem
 */
export const OfflineLoggingItem = new OfflineLoggingItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetOfflineParameterDataRequest$Type extends MessageType<GetOfflineParameterDataRequest> {
    constructor() {
        super("offlineMessaging.GetOfflineParameterDataRequest", [
            { no: 1, name: "messageHeader", kind: "message", T: () => OfflineMessageHeader },
            { no: 2, name: "payloadType", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetOfflineParameterDataRequest>): GetOfflineParameterDataRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payloadType = "";
        if (value !== undefined)
            reflectionMergePartial<GetOfflineParameterDataRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetOfflineParameterDataRequest): GetOfflineParameterDataRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.OfflineMessageHeader messageHeader */ 1:
                    message.messageHeader = OfflineMessageHeader.internalBinaryRead(reader, reader.uint32(), options, message.messageHeader);
                    break;
                case /* string payloadType */ 2:
                    message.payloadType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetOfflineParameterDataRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.OfflineMessageHeader messageHeader = 1; */
        if (message.messageHeader)
            OfflineMessageHeader.internalBinaryWrite(message.messageHeader, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string payloadType = 2; */
        if (message.payloadType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.payloadType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.GetOfflineParameterDataRequest
 */
export const GetOfflineParameterDataRequest = new GetOfflineParameterDataRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetOfflineParameterDataResponse$Type extends MessageType<GetOfflineParameterDataResponse> {
    constructor() {
        super("offlineMessaging.GetOfflineParameterDataResponse", [
            { no: 1, name: "responseStatus", kind: "message", T: () => OfflineResponse },
            { no: 2, name: "parameters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CachedParameterItem }
        ]);
    }
    create(value?: PartialMessage<GetOfflineParameterDataResponse>): GetOfflineParameterDataResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.parameters = [];
        if (value !== undefined)
            reflectionMergePartial<GetOfflineParameterDataResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetOfflineParameterDataResponse): GetOfflineParameterDataResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.OfflineResponse responseStatus */ 1:
                    message.responseStatus = OfflineResponse.internalBinaryRead(reader, reader.uint32(), options, message.responseStatus);
                    break;
                case /* repeated offlineMessaging.CachedParameterItem parameters */ 2:
                    message.parameters.push(CachedParameterItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetOfflineParameterDataResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.OfflineResponse responseStatus = 1; */
        if (message.responseStatus)
            OfflineResponse.internalBinaryWrite(message.responseStatus, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated offlineMessaging.CachedParameterItem parameters = 2; */
        for (let i = 0; i < message.parameters.length; i++)
            CachedParameterItem.internalBinaryWrite(message.parameters[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.GetOfflineParameterDataResponse
 */
export const GetOfflineParameterDataResponse = new GetOfflineParameterDataResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveOfflineParameterRequest$Type extends MessageType<SaveOfflineParameterRequest> {
    constructor() {
        super("offlineMessaging.SaveOfflineParameterRequest", [
            { no: 1, name: "messageHeader", kind: "message", T: () => OfflineMessageHeader },
            { no: 2, name: "payloadType", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "payload", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "enpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "expiresIn", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "expirationUnit", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SaveOfflineParameterRequest>): SaveOfflineParameterRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payloadType = "";
        message.payload = "";
        message.enpoint = "";
        message.expiresIn = 0;
        message.expirationUnit = "";
        if (value !== undefined)
            reflectionMergePartial<SaveOfflineParameterRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveOfflineParameterRequest): SaveOfflineParameterRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.OfflineMessageHeader messageHeader */ 1:
                    message.messageHeader = OfflineMessageHeader.internalBinaryRead(reader, reader.uint32(), options, message.messageHeader);
                    break;
                case /* string payloadType */ 2:
                    message.payloadType = reader.string();
                    break;
                case /* string payload */ 3:
                    message.payload = reader.string();
                    break;
                case /* string enpoint */ 4:
                    message.enpoint = reader.string();
                    break;
                case /* int32 expiresIn */ 5:
                    message.expiresIn = reader.int32();
                    break;
                case /* string expirationUnit */ 6:
                    message.expirationUnit = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveOfflineParameterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.OfflineMessageHeader messageHeader = 1; */
        if (message.messageHeader)
            OfflineMessageHeader.internalBinaryWrite(message.messageHeader, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string payloadType = 2; */
        if (message.payloadType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.payloadType);
        /* string payload = 3; */
        if (message.payload !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.payload);
        /* string enpoint = 4; */
        if (message.enpoint !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.enpoint);
        /* int32 expiresIn = 5; */
        if (message.expiresIn !== 0)
            writer.tag(5, WireType.Varint).int32(message.expiresIn);
        /* string expirationUnit = 6; */
        if (message.expirationUnit !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.expirationUnit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.SaveOfflineParameterRequest
 */
export const SaveOfflineParameterRequest = new SaveOfflineParameterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteOfflineParameterRequest$Type extends MessageType<DeleteOfflineParameterRequest> {
    constructor() {
        super("offlineMessaging.DeleteOfflineParameterRequest", [
            { no: 1, name: "messageHeader", kind: "message", T: () => OfflineMessageHeader },
            { no: 2, name: "payloadType", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteOfflineParameterRequest>): DeleteOfflineParameterRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payloadType = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteOfflineParameterRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteOfflineParameterRequest): DeleteOfflineParameterRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.OfflineMessageHeader messageHeader */ 1:
                    message.messageHeader = OfflineMessageHeader.internalBinaryRead(reader, reader.uint32(), options, message.messageHeader);
                    break;
                case /* string payloadType */ 2:
                    message.payloadType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteOfflineParameterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.OfflineMessageHeader messageHeader = 1; */
        if (message.messageHeader)
            OfflineMessageHeader.internalBinaryWrite(message.messageHeader, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string payloadType = 2; */
        if (message.payloadType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.payloadType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.DeleteOfflineParameterRequest
 */
export const DeleteOfflineParameterRequest = new DeleteOfflineParameterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetOfflineTransactionDataRequest$Type extends MessageType<GetOfflineTransactionDataRequest> {
    constructor() {
        super("offlineMessaging.GetOfflineTransactionDataRequest", [
            { no: 1, name: "messageHeader", kind: "message", T: () => OfflineMessageHeader },
            { no: 2, name: "payloadType", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "processingDate", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetOfflineTransactionDataRequest>): GetOfflineTransactionDataRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payloadType = "";
        message.processingDate = "";
        if (value !== undefined)
            reflectionMergePartial<GetOfflineTransactionDataRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetOfflineTransactionDataRequest): GetOfflineTransactionDataRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.OfflineMessageHeader messageHeader */ 1:
                    message.messageHeader = OfflineMessageHeader.internalBinaryRead(reader, reader.uint32(), options, message.messageHeader);
                    break;
                case /* string payloadType */ 2:
                    message.payloadType = reader.string();
                    break;
                case /* string processingDate */ 3:
                    message.processingDate = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetOfflineTransactionDataRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.OfflineMessageHeader messageHeader = 1; */
        if (message.messageHeader)
            OfflineMessageHeader.internalBinaryWrite(message.messageHeader, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string payloadType = 2; */
        if (message.payloadType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.payloadType);
        /* string processingDate = 3; */
        if (message.processingDate !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.processingDate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.GetOfflineTransactionDataRequest
 */
export const GetOfflineTransactionDataRequest = new GetOfflineTransactionDataRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetOfflineTransactionDataResponse$Type extends MessageType<GetOfflineTransactionDataResponse> {
    constructor() {
        super("offlineMessaging.GetOfflineTransactionDataResponse", [
            { no: 1, name: "responseStatus", kind: "message", T: () => OfflineResponse },
            { no: 2, name: "transactions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CachedTransactionItem }
        ]);
    }
    create(value?: PartialMessage<GetOfflineTransactionDataResponse>): GetOfflineTransactionDataResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transactions = [];
        if (value !== undefined)
            reflectionMergePartial<GetOfflineTransactionDataResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetOfflineTransactionDataResponse): GetOfflineTransactionDataResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.OfflineResponse responseStatus */ 1:
                    message.responseStatus = OfflineResponse.internalBinaryRead(reader, reader.uint32(), options, message.responseStatus);
                    break;
                case /* repeated offlineMessaging.CachedTransactionItem transactions */ 2:
                    message.transactions.push(CachedTransactionItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetOfflineTransactionDataResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.OfflineResponse responseStatus = 1; */
        if (message.responseStatus)
            OfflineResponse.internalBinaryWrite(message.responseStatus, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated offlineMessaging.CachedTransactionItem transactions = 2; */
        for (let i = 0; i < message.transactions.length; i++)
            CachedTransactionItem.internalBinaryWrite(message.transactions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.GetOfflineTransactionDataResponse
 */
export const GetOfflineTransactionDataResponse = new GetOfflineTransactionDataResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveOfflineTransactionReqeust$Type extends MessageType<SaveOfflineTransactionReqeust> {
    constructor() {
        super("offlineMessaging.SaveOfflineTransactionReqeust", [
            { no: 1, name: "messageHeader", kind: "message", T: () => OfflineMessageHeader },
            { no: 2, name: "processingDate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "payloadType", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "payload", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "enpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "sendResult", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "lastSendAttempt", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SaveOfflineTransactionReqeust>): SaveOfflineTransactionReqeust {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.processingDate = "";
        message.payloadType = "";
        message.payload = "";
        message.enpoint = "";
        message.sendResult = "";
        message.lastSendAttempt = "";
        if (value !== undefined)
            reflectionMergePartial<SaveOfflineTransactionReqeust>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveOfflineTransactionReqeust): SaveOfflineTransactionReqeust {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.OfflineMessageHeader messageHeader */ 1:
                    message.messageHeader = OfflineMessageHeader.internalBinaryRead(reader, reader.uint32(), options, message.messageHeader);
                    break;
                case /* string processingDate */ 2:
                    message.processingDate = reader.string();
                    break;
                case /* string payloadType */ 3:
                    message.payloadType = reader.string();
                    break;
                case /* string payload */ 4:
                    message.payload = reader.string();
                    break;
                case /* string enpoint */ 5:
                    message.enpoint = reader.string();
                    break;
                case /* string sendResult */ 6:
                    message.sendResult = reader.string();
                    break;
                case /* string lastSendAttempt */ 7:
                    message.lastSendAttempt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveOfflineTransactionReqeust, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.OfflineMessageHeader messageHeader = 1; */
        if (message.messageHeader)
            OfflineMessageHeader.internalBinaryWrite(message.messageHeader, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string processingDate = 2; */
        if (message.processingDate !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.processingDate);
        /* string payloadType = 3; */
        if (message.payloadType !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.payloadType);
        /* string payload = 4; */
        if (message.payload !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.payload);
        /* string enpoint = 5; */
        if (message.enpoint !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.enpoint);
        /* string sendResult = 6; */
        if (message.sendResult !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.sendResult);
        /* string lastSendAttempt = 7; */
        if (message.lastSendAttempt !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.lastSendAttempt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.SaveOfflineTransactionReqeust
 */
export const SaveOfflineTransactionReqeust = new SaveOfflineTransactionReqeust$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteOfflineTransactionRequest$Type extends MessageType<DeleteOfflineTransactionRequest> {
    constructor() {
        super("offlineMessaging.DeleteOfflineTransactionRequest", [
            { no: 1, name: "messageHeader", kind: "message", T: () => OfflineMessageHeader },
            { no: 2, name: "payloadType", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "processingDate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "dateAdded", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "rowID", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteOfflineTransactionRequest>): DeleteOfflineTransactionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payloadType = "";
        message.processingDate = "";
        message.dateAdded = "";
        message.rowID = 0;
        if (value !== undefined)
            reflectionMergePartial<DeleteOfflineTransactionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteOfflineTransactionRequest): DeleteOfflineTransactionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.OfflineMessageHeader messageHeader */ 1:
                    message.messageHeader = OfflineMessageHeader.internalBinaryRead(reader, reader.uint32(), options, message.messageHeader);
                    break;
                case /* string payloadType */ 2:
                    message.payloadType = reader.string();
                    break;
                case /* string processingDate */ 3:
                    message.processingDate = reader.string();
                    break;
                case /* string dateAdded */ 4:
                    message.dateAdded = reader.string();
                    break;
                case /* int32 rowID */ 5:
                    message.rowID = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteOfflineTransactionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.OfflineMessageHeader messageHeader = 1; */
        if (message.messageHeader)
            OfflineMessageHeader.internalBinaryWrite(message.messageHeader, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string payloadType = 2; */
        if (message.payloadType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.payloadType);
        /* string processingDate = 3; */
        if (message.processingDate !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.processingDate);
        /* string dateAdded = 4; */
        if (message.dateAdded !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.dateAdded);
        /* int32 rowID = 5; */
        if (message.rowID !== 0)
            writer.tag(5, WireType.Varint).int32(message.rowID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.DeleteOfflineTransactionRequest
 */
export const DeleteOfflineTransactionRequest = new DeleteOfflineTransactionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCachedResponsesRequest$Type extends MessageType<GetCachedResponsesRequest> {
    constructor() {
        super("offlineMessaging.GetCachedResponsesRequest", [
            { no: 1, name: "messageHeader", kind: "message", T: () => OfflineMessageHeader },
            { no: 2, name: "processingDate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "payloadType", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetCachedResponsesRequest>): GetCachedResponsesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.processingDate = "";
        message.payloadType = "";
        if (value !== undefined)
            reflectionMergePartial<GetCachedResponsesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCachedResponsesRequest): GetCachedResponsesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.OfflineMessageHeader messageHeader */ 1:
                    message.messageHeader = OfflineMessageHeader.internalBinaryRead(reader, reader.uint32(), options, message.messageHeader);
                    break;
                case /* string processingDate */ 2:
                    message.processingDate = reader.string();
                    break;
                case /* string payloadType */ 3:
                    message.payloadType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCachedResponsesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.OfflineMessageHeader messageHeader = 1; */
        if (message.messageHeader)
            OfflineMessageHeader.internalBinaryWrite(message.messageHeader, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string processingDate = 2; */
        if (message.processingDate !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.processingDate);
        /* string payloadType = 3; */
        if (message.payloadType !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.payloadType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.GetCachedResponsesRequest
 */
export const GetCachedResponsesRequest = new GetCachedResponsesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCachedResponsesResponse$Type extends MessageType<GetCachedResponsesResponse> {
    constructor() {
        super("offlineMessaging.GetCachedResponsesResponse", [
            { no: 1, name: "responseStatus", kind: "message", T: () => OfflineResponse },
            { no: 2, name: "cachedResponses", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CachedResponseItem }
        ]);
    }
    create(value?: PartialMessage<GetCachedResponsesResponse>): GetCachedResponsesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cachedResponses = [];
        if (value !== undefined)
            reflectionMergePartial<GetCachedResponsesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCachedResponsesResponse): GetCachedResponsesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.OfflineResponse responseStatus */ 1:
                    message.responseStatus = OfflineResponse.internalBinaryRead(reader, reader.uint32(), options, message.responseStatus);
                    break;
                case /* repeated offlineMessaging.CachedResponseItem cachedResponses */ 2:
                    message.cachedResponses.push(CachedResponseItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCachedResponsesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.OfflineResponse responseStatus = 1; */
        if (message.responseStatus)
            OfflineResponse.internalBinaryWrite(message.responseStatus, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated offlineMessaging.CachedResponseItem cachedResponses = 2; */
        for (let i = 0; i < message.cachedResponses.length; i++)
            CachedResponseItem.internalBinaryWrite(message.cachedResponses[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.GetCachedResponsesResponse
 */
export const GetCachedResponsesResponse = new GetCachedResponsesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveCachedResponseRequest$Type extends MessageType<SaveCachedResponseRequest> {
    constructor() {
        super("offlineMessaging.SaveCachedResponseRequest", [
            { no: 2, name: "responseItem", kind: "message", T: () => CachedResponseItem }
        ]);
    }
    create(value?: PartialMessage<SaveCachedResponseRequest>): SaveCachedResponseRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SaveCachedResponseRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveCachedResponseRequest): SaveCachedResponseRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.CachedResponseItem responseItem */ 2:
                    message.responseItem = CachedResponseItem.internalBinaryRead(reader, reader.uint32(), options, message.responseItem);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveCachedResponseRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.CachedResponseItem responseItem = 2; */
        if (message.responseItem)
            CachedResponseItem.internalBinaryWrite(message.responseItem, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.SaveCachedResponseRequest
 */
export const SaveCachedResponseRequest = new SaveCachedResponseRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteCachedResponseRequest$Type extends MessageType<DeleteCachedResponseRequest> {
    constructor() {
        super("offlineMessaging.DeleteCachedResponseRequest", [
            { no: 1, name: "messageHeader", kind: "message", T: () => OfflineMessageHeader },
            { no: 2, name: "payloadType", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "processingDate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "dateAdded", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "responsePayload", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteCachedResponseRequest>): DeleteCachedResponseRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payloadType = "";
        message.processingDate = "";
        message.dateAdded = "";
        message.responsePayload = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteCachedResponseRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteCachedResponseRequest): DeleteCachedResponseRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.OfflineMessageHeader messageHeader */ 1:
                    message.messageHeader = OfflineMessageHeader.internalBinaryRead(reader, reader.uint32(), options, message.messageHeader);
                    break;
                case /* string payloadType */ 2:
                    message.payloadType = reader.string();
                    break;
                case /* string processingDate */ 3:
                    message.processingDate = reader.string();
                    break;
                case /* string dateAdded */ 4:
                    message.dateAdded = reader.string();
                    break;
                case /* string responsePayload */ 5:
                    message.responsePayload = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteCachedResponseRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.OfflineMessageHeader messageHeader = 1; */
        if (message.messageHeader)
            OfflineMessageHeader.internalBinaryWrite(message.messageHeader, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string payloadType = 2; */
        if (message.payloadType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.payloadType);
        /* string processingDate = 3; */
        if (message.processingDate !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.processingDate);
        /* string dateAdded = 4; */
        if (message.dateAdded !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.dateAdded);
        /* string responsePayload = 5; */
        if (message.responsePayload !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.responsePayload);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.DeleteCachedResponseRequest
 */
export const DeleteCachedResponseRequest = new DeleteCachedResponseRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDeadletterQueueDataRequest$Type extends MessageType<GetDeadletterQueueDataRequest> {
    constructor() {
        super("offlineMessaging.GetDeadletterQueueDataRequest", [
            { no: 1, name: "messageHeader", kind: "message", T: () => OfflineMessageHeader },
            { no: 2, name: "payloadType", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "processingDate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "dateAdded", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetDeadletterQueueDataRequest>): GetDeadletterQueueDataRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payloadType = "";
        message.processingDate = "";
        message.dateAdded = "";
        if (value !== undefined)
            reflectionMergePartial<GetDeadletterQueueDataRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDeadletterQueueDataRequest): GetDeadletterQueueDataRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.OfflineMessageHeader messageHeader */ 1:
                    message.messageHeader = OfflineMessageHeader.internalBinaryRead(reader, reader.uint32(), options, message.messageHeader);
                    break;
                case /* string payloadType */ 2:
                    message.payloadType = reader.string();
                    break;
                case /* string processingDate */ 3:
                    message.processingDate = reader.string();
                    break;
                case /* string dateAdded */ 4:
                    message.dateAdded = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDeadletterQueueDataRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.OfflineMessageHeader messageHeader = 1; */
        if (message.messageHeader)
            OfflineMessageHeader.internalBinaryWrite(message.messageHeader, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string payloadType = 2; */
        if (message.payloadType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.payloadType);
        /* string processingDate = 3; */
        if (message.processingDate !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.processingDate);
        /* string dateAdded = 4; */
        if (message.dateAdded !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.dateAdded);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.GetDeadletterQueueDataRequest
 */
export const GetDeadletterQueueDataRequest = new GetDeadletterQueueDataRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDeadletterQueueDataResponse$Type extends MessageType<GetDeadletterQueueDataResponse> {
    constructor() {
        super("offlineMessaging.GetDeadletterQueueDataResponse", [
            { no: 1, name: "responseStatus", kind: "message", T: () => OfflineResponse },
            { no: 2, name: "deadletterItems", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CachedTransactionItem }
        ]);
    }
    create(value?: PartialMessage<GetDeadletterQueueDataResponse>): GetDeadletterQueueDataResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.deadletterItems = [];
        if (value !== undefined)
            reflectionMergePartial<GetDeadletterQueueDataResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDeadletterQueueDataResponse): GetDeadletterQueueDataResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.OfflineResponse responseStatus */ 1:
                    message.responseStatus = OfflineResponse.internalBinaryRead(reader, reader.uint32(), options, message.responseStatus);
                    break;
                case /* repeated offlineMessaging.CachedTransactionItem deadletterItems */ 2:
                    message.deadletterItems.push(CachedTransactionItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDeadletterQueueDataResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.OfflineResponse responseStatus = 1; */
        if (message.responseStatus)
            OfflineResponse.internalBinaryWrite(message.responseStatus, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated offlineMessaging.CachedTransactionItem deadletterItems = 2; */
        for (let i = 0; i < message.deadletterItems.length; i++)
            CachedTransactionItem.internalBinaryWrite(message.deadletterItems[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.GetDeadletterQueueDataResponse
 */
export const GetDeadletterQueueDataResponse = new GetDeadletterQueueDataResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveDeadletterQueueDataRequest$Type extends MessageType<SaveDeadletterQueueDataRequest> {
    constructor() {
        super("offlineMessaging.SaveDeadletterQueueDataRequest", [
            { no: 1, name: "transactionItem", kind: "message", T: () => CachedTransactionItem },
            { no: 2, name: "deadLetterExpiration", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SaveDeadletterQueueDataRequest>): SaveDeadletterQueueDataRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.deadLetterExpiration = "";
        if (value !== undefined)
            reflectionMergePartial<SaveDeadletterQueueDataRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveDeadletterQueueDataRequest): SaveDeadletterQueueDataRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.CachedTransactionItem transactionItem */ 1:
                    message.transactionItem = CachedTransactionItem.internalBinaryRead(reader, reader.uint32(), options, message.transactionItem);
                    break;
                case /* string deadLetterExpiration */ 2:
                    message.deadLetterExpiration = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveDeadletterQueueDataRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.CachedTransactionItem transactionItem = 1; */
        if (message.transactionItem)
            CachedTransactionItem.internalBinaryWrite(message.transactionItem, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string deadLetterExpiration = 2; */
        if (message.deadLetterExpiration !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.deadLetterExpiration);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.SaveDeadletterQueueDataRequest
 */
export const SaveDeadletterQueueDataRequest = new SaveDeadletterQueueDataRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveDeadletterQueueDataResponse$Type extends MessageType<SaveDeadletterQueueDataResponse> {
    constructor() {
        super("offlineMessaging.SaveDeadletterQueueDataResponse", [
            { no: 1, name: "responseStatus", kind: "message", T: () => OfflineResponse },
            { no: 2, name: "transactionItem", kind: "message", T: () => CachedTransactionItem }
        ]);
    }
    create(value?: PartialMessage<SaveDeadletterQueueDataResponse>): SaveDeadletterQueueDataResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SaveDeadletterQueueDataResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveDeadletterQueueDataResponse): SaveDeadletterQueueDataResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.OfflineResponse responseStatus */ 1:
                    message.responseStatus = OfflineResponse.internalBinaryRead(reader, reader.uint32(), options, message.responseStatus);
                    break;
                case /* offlineMessaging.CachedTransactionItem transactionItem */ 2:
                    message.transactionItem = CachedTransactionItem.internalBinaryRead(reader, reader.uint32(), options, message.transactionItem);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveDeadletterQueueDataResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.OfflineResponse responseStatus = 1; */
        if (message.responseStatus)
            OfflineResponse.internalBinaryWrite(message.responseStatus, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* offlineMessaging.CachedTransactionItem transactionItem = 2; */
        if (message.transactionItem)
            CachedTransactionItem.internalBinaryWrite(message.transactionItem, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.SaveDeadletterQueueDataResponse
 */
export const SaveDeadletterQueueDataResponse = new SaveDeadletterQueueDataResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteDeadletterQueueDataRequest$Type extends MessageType<DeleteDeadletterQueueDataRequest> {
    constructor() {
        super("offlineMessaging.DeleteDeadletterQueueDataRequest", [
            { no: 1, name: "messageHeader", kind: "message", T: () => OfflineMessageHeader },
            { no: 2, name: "payloadType", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "processingDate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "dateAdded", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "rowID", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteDeadletterQueueDataRequest>): DeleteDeadletterQueueDataRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payloadType = "";
        message.processingDate = "";
        message.dateAdded = "";
        message.rowID = 0;
        if (value !== undefined)
            reflectionMergePartial<DeleteDeadletterQueueDataRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteDeadletterQueueDataRequest): DeleteDeadletterQueueDataRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.OfflineMessageHeader messageHeader */ 1:
                    message.messageHeader = OfflineMessageHeader.internalBinaryRead(reader, reader.uint32(), options, message.messageHeader);
                    break;
                case /* string payloadType */ 2:
                    message.payloadType = reader.string();
                    break;
                case /* string processingDate */ 3:
                    message.processingDate = reader.string();
                    break;
                case /* string dateAdded */ 4:
                    message.dateAdded = reader.string();
                    break;
                case /* int32 rowID */ 5:
                    message.rowID = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteDeadletterQueueDataRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.OfflineMessageHeader messageHeader = 1; */
        if (message.messageHeader)
            OfflineMessageHeader.internalBinaryWrite(message.messageHeader, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string payloadType = 2; */
        if (message.payloadType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.payloadType);
        /* string processingDate = 3; */
        if (message.processingDate !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.processingDate);
        /* string dateAdded = 4; */
        if (message.dateAdded !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.dateAdded);
        /* int32 rowID = 5; */
        if (message.rowID !== 0)
            writer.tag(5, WireType.Varint).int32(message.rowID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.DeleteDeadletterQueueDataRequest
 */
export const DeleteDeadletterQueueDataRequest = new DeleteDeadletterQueueDataRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUserSettingsRequest$Type extends MessageType<GetUserSettingsRequest> {
    constructor() {
        super("offlineMessaging.GetUserSettingsRequest", [
            { no: 1, name: "messageHeader", kind: "message", T: () => OfflineMessageHeader },
            { no: 2, name: "instanceName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "settingKey", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetUserSettingsRequest>): GetUserSettingsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.instanceName = "";
        message.settingKey = "";
        if (value !== undefined)
            reflectionMergePartial<GetUserSettingsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUserSettingsRequest): GetUserSettingsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.OfflineMessageHeader messageHeader */ 1:
                    message.messageHeader = OfflineMessageHeader.internalBinaryRead(reader, reader.uint32(), options, message.messageHeader);
                    break;
                case /* string instanceName */ 2:
                    message.instanceName = reader.string();
                    break;
                case /* string settingKey */ 3:
                    message.settingKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUserSettingsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.OfflineMessageHeader messageHeader = 1; */
        if (message.messageHeader)
            OfflineMessageHeader.internalBinaryWrite(message.messageHeader, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string instanceName = 2; */
        if (message.instanceName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.instanceName);
        /* string settingKey = 3; */
        if (message.settingKey !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.settingKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.GetUserSettingsRequest
 */
export const GetUserSettingsRequest = new GetUserSettingsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUserSettingsResponse$Type extends MessageType<GetUserSettingsResponse> {
    constructor() {
        super("offlineMessaging.GetUserSettingsResponse", [
            { no: 1, name: "responseStatus", kind: "message", T: () => OfflineResponse },
            { no: 2, name: "userSettings", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UserSettingsItem }
        ]);
    }
    create(value?: PartialMessage<GetUserSettingsResponse>): GetUserSettingsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userSettings = [];
        if (value !== undefined)
            reflectionMergePartial<GetUserSettingsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUserSettingsResponse): GetUserSettingsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.OfflineResponse responseStatus */ 1:
                    message.responseStatus = OfflineResponse.internalBinaryRead(reader, reader.uint32(), options, message.responseStatus);
                    break;
                case /* repeated offlineMessaging.UserSettingsItem userSettings */ 2:
                    message.userSettings.push(UserSettingsItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUserSettingsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.OfflineResponse responseStatus = 1; */
        if (message.responseStatus)
            OfflineResponse.internalBinaryWrite(message.responseStatus, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated offlineMessaging.UserSettingsItem userSettings = 2; */
        for (let i = 0; i < message.userSettings.length; i++)
            UserSettingsItem.internalBinaryWrite(message.userSettings[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.GetUserSettingsResponse
 */
export const GetUserSettingsResponse = new GetUserSettingsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveUserSettingsRequest$Type extends MessageType<SaveUserSettingsRequest> {
    constructor() {
        super("offlineMessaging.SaveUserSettingsRequest", [
            { no: 1, name: "messageHeader", kind: "message", T: () => OfflineMessageHeader },
            { no: 2, name: "instanceName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "settingKey", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "setting", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SaveUserSettingsRequest>): SaveUserSettingsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.instanceName = "";
        message.settingKey = "";
        message.setting = "";
        if (value !== undefined)
            reflectionMergePartial<SaveUserSettingsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveUserSettingsRequest): SaveUserSettingsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.OfflineMessageHeader messageHeader */ 1:
                    message.messageHeader = OfflineMessageHeader.internalBinaryRead(reader, reader.uint32(), options, message.messageHeader);
                    break;
                case /* string instanceName */ 2:
                    message.instanceName = reader.string();
                    break;
                case /* string settingKey */ 3:
                    message.settingKey = reader.string();
                    break;
                case /* string setting */ 4:
                    message.setting = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveUserSettingsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.OfflineMessageHeader messageHeader = 1; */
        if (message.messageHeader)
            OfflineMessageHeader.internalBinaryWrite(message.messageHeader, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string instanceName = 2; */
        if (message.instanceName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.instanceName);
        /* string settingKey = 3; */
        if (message.settingKey !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.settingKey);
        /* string setting = 4; */
        if (message.setting !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.setting);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.SaveUserSettingsRequest
 */
export const SaveUserSettingsRequest = new SaveUserSettingsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteUserSettingRequest$Type extends MessageType<DeleteUserSettingRequest> {
    constructor() {
        super("offlineMessaging.DeleteUserSettingRequest", [
            { no: 1, name: "messageHeader", kind: "message", T: () => OfflineMessageHeader },
            { no: 2, name: "instanceName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "settingKey", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteUserSettingRequest>): DeleteUserSettingRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.instanceName = "";
        message.settingKey = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteUserSettingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteUserSettingRequest): DeleteUserSettingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.OfflineMessageHeader messageHeader */ 1:
                    message.messageHeader = OfflineMessageHeader.internalBinaryRead(reader, reader.uint32(), options, message.messageHeader);
                    break;
                case /* string instanceName */ 2:
                    message.instanceName = reader.string();
                    break;
                case /* string settingKey */ 3:
                    message.settingKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteUserSettingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.OfflineMessageHeader messageHeader = 1; */
        if (message.messageHeader)
            OfflineMessageHeader.internalBinaryWrite(message.messageHeader, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string instanceName = 2; */
        if (message.instanceName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.instanceName);
        /* string settingKey = 3; */
        if (message.settingKey !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.settingKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.DeleteUserSettingRequest
 */
export const DeleteUserSettingRequest = new DeleteUserSettingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LogonUserRequest$Type extends MessageType<LogonUserRequest> {
    constructor() {
        super("offlineMessaging.LogonUserRequest", [
            { no: 1, name: "messageHeader", kind: "message", T: () => OfflineMessageHeader },
            { no: 2, name: "userToken", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tokenExpiration", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LogonUserRequest>): LogonUserRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userToken = "";
        message.tokenExpiration = "";
        if (value !== undefined)
            reflectionMergePartial<LogonUserRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LogonUserRequest): LogonUserRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.OfflineMessageHeader messageHeader */ 1:
                    message.messageHeader = OfflineMessageHeader.internalBinaryRead(reader, reader.uint32(), options, message.messageHeader);
                    break;
                case /* string userToken */ 2:
                    message.userToken = reader.string();
                    break;
                case /* string tokenExpiration */ 3:
                    message.tokenExpiration = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LogonUserRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.OfflineMessageHeader messageHeader = 1; */
        if (message.messageHeader)
            OfflineMessageHeader.internalBinaryWrite(message.messageHeader, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string userToken = 2; */
        if (message.userToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userToken);
        /* string tokenExpiration = 3; */
        if (message.tokenExpiration !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.tokenExpiration);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.LogonUserRequest
 */
export const LogonUserRequest = new LogonUserRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LogOffUserRequest$Type extends MessageType<LogOffUserRequest> {
    constructor() {
        super("offlineMessaging.LogOffUserRequest", [
            { no: 1, name: "messageHeader", kind: "message", T: () => OfflineMessageHeader }
        ]);
    }
    create(value?: PartialMessage<LogOffUserRequest>): LogOffUserRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LogOffUserRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LogOffUserRequest): LogOffUserRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.OfflineMessageHeader messageHeader */ 1:
                    message.messageHeader = OfflineMessageHeader.internalBinaryRead(reader, reader.uint32(), options, message.messageHeader);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LogOffUserRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.OfflineMessageHeader messageHeader = 1; */
        if (message.messageHeader)
            OfflineMessageHeader.internalBinaryWrite(message.messageHeader, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.LogOffUserRequest
 */
export const LogOffUserRequest = new LogOffUserRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWorkstationNameRequest$Type extends MessageType<GetWorkstationNameRequest> {
    constructor() {
        super("offlineMessaging.GetWorkstationNameRequest", [
            { no: 1, name: "workstationID", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetWorkstationNameRequest>): GetWorkstationNameRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workstationID = "";
        if (value !== undefined)
            reflectionMergePartial<GetWorkstationNameRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWorkstationNameRequest): GetWorkstationNameRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string workstationID */ 1:
                    message.workstationID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWorkstationNameRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string workstationID = 1; */
        if (message.workstationID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.workstationID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.GetWorkstationNameRequest
 */
export const GetWorkstationNameRequest = new GetWorkstationNameRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWorkstationNameResponse$Type extends MessageType<GetWorkstationNameResponse> {
    constructor() {
        super("offlineMessaging.GetWorkstationNameResponse", [
            { no: 1, name: "workstationID", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetWorkstationNameResponse>): GetWorkstationNameResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workstationID = "";
        if (value !== undefined)
            reflectionMergePartial<GetWorkstationNameResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWorkstationNameResponse): GetWorkstationNameResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string workstationID */ 1:
                    message.workstationID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWorkstationNameResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string workstationID = 1; */
        if (message.workstationID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.workstationID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.GetWorkstationNameResponse
 */
export const GetWorkstationNameResponse = new GetWorkstationNameResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetOfflineLogItemsRequest$Type extends MessageType<GetOfflineLogItemsRequest> {
    constructor() {
        super("offlineMessaging.GetOfflineLogItemsRequest", [
            { no: 1, name: "messageHeader", kind: "message", T: () => OfflineMessageHeader }
        ]);
    }
    create(value?: PartialMessage<GetOfflineLogItemsRequest>): GetOfflineLogItemsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetOfflineLogItemsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetOfflineLogItemsRequest): GetOfflineLogItemsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.OfflineMessageHeader messageHeader */ 1:
                    message.messageHeader = OfflineMessageHeader.internalBinaryRead(reader, reader.uint32(), options, message.messageHeader);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetOfflineLogItemsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.OfflineMessageHeader messageHeader = 1; */
        if (message.messageHeader)
            OfflineMessageHeader.internalBinaryWrite(message.messageHeader, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.GetOfflineLogItemsRequest
 */
export const GetOfflineLogItemsRequest = new GetOfflineLogItemsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetOfflineLogItemsResponse$Type extends MessageType<GetOfflineLogItemsResponse> {
    constructor() {
        super("offlineMessaging.GetOfflineLogItemsResponse", [
            { no: 1, name: "responseStatus", kind: "message", T: () => OfflineResponse },
            { no: 2, name: "LogItems", kind: "message", jsonName: "LogItems", repeat: 1 /*RepeatType.PACKED*/, T: () => OfflineLoggingItem }
        ]);
    }
    create(value?: PartialMessage<GetOfflineLogItemsResponse>): GetOfflineLogItemsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.logItems = [];
        if (value !== undefined)
            reflectionMergePartial<GetOfflineLogItemsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetOfflineLogItemsResponse): GetOfflineLogItemsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.OfflineResponse responseStatus */ 1:
                    message.responseStatus = OfflineResponse.internalBinaryRead(reader, reader.uint32(), options, message.responseStatus);
                    break;
                case /* repeated offlineMessaging.OfflineLoggingItem LogItems = 2 [json_name = "LogItems"];*/ 2:
                    message.logItems.push(OfflineLoggingItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetOfflineLogItemsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.OfflineResponse responseStatus = 1; */
        if (message.responseStatus)
            OfflineResponse.internalBinaryWrite(message.responseStatus, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated offlineMessaging.OfflineLoggingItem LogItems = 2 [json_name = "LogItems"]; */
        for (let i = 0; i < message.logItems.length; i++)
            OfflineLoggingItem.internalBinaryWrite(message.logItems[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.GetOfflineLogItemsResponse
 */
export const GetOfflineLogItemsResponse = new GetOfflineLogItemsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveOfflineLogItemRequest$Type extends MessageType<SaveOfflineLogItemRequest> {
    constructor() {
        super("offlineMessaging.SaveOfflineLogItemRequest", [
            { no: 1, name: "logItem", kind: "message", T: () => OfflineLoggingItem }
        ]);
    }
    create(value?: PartialMessage<SaveOfflineLogItemRequest>): SaveOfflineLogItemRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SaveOfflineLogItemRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveOfflineLogItemRequest): SaveOfflineLogItemRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* offlineMessaging.OfflineLoggingItem logItem */ 1:
                    message.logItem = OfflineLoggingItem.internalBinaryRead(reader, reader.uint32(), options, message.logItem);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveOfflineLogItemRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* offlineMessaging.OfflineLoggingItem logItem = 1; */
        if (message.logItem)
            OfflineLoggingItem.internalBinaryWrite(message.logItem, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offlineMessaging.SaveOfflineLogItemRequest
 */
export const SaveOfflineLogItemRequest = new SaveOfflineLogItemRequest$Type();
/**
 * @generated ServiceType for protobuf service offlineMessaging.OfflineMessaging
 */
export const OfflineMessaging = new ServiceType("offlineMessaging.OfflineMessaging", [
    { name: "GetOfflineParameterData", options: {}, I: GetOfflineParameterDataRequest, O: GetOfflineParameterDataResponse },
    { name: "GetOfflineTransactionData", options: {}, I: GetOfflineTransactionDataRequest, O: GetOfflineTransactionDataResponse },
    { name: "GetCachedResponseData", options: {}, I: GetCachedResponsesRequest, O: GetCachedResponsesResponse },
    { name: "GetUserSettingsData", options: {}, I: GetUserSettingsRequest, O: GetUserSettingsResponse },
    { name: "GetDeadletterQueueData", options: {}, I: GetDeadletterQueueDataRequest, O: GetDeadletterQueueDataResponse },
    { name: "GetOfflineLogData", options: {}, I: GetOfflineLogItemsRequest, O: GetOfflineLogItemsResponse },
    { name: "SaveOfflineParameterData", options: {}, I: SaveOfflineParameterRequest, O: OfflineResponse },
    { name: "SaveOfflineTransactionData", options: {}, I: SaveOfflineTransactionReqeust, O: OfflineResponse },
    { name: "SaveUserSettingsData", options: {}, I: SaveUserSettingsRequest, O: OfflineResponse },
    { name: "SaveDeadletterQueueData", options: {}, I: SaveDeadletterQueueDataRequest, O: OfflineResponse },
    { name: "SaveCachedResponseData", options: {}, I: SaveCachedResponseRequest, O: OfflineResponse },
    { name: "SaveOfflineLogData", options: {}, I: SaveOfflineLogItemRequest, O: OfflineResponse },
    { name: "DeleteOfflineParameterData", options: {}, I: DeleteOfflineParameterRequest, O: OfflineResponse },
    { name: "DeleteOfflneTransactionData", options: {}, I: DeleteOfflineTransactionRequest, O: OfflineResponse },
    { name: "DeleteUserSettingData", options: {}, I: DeleteUserSettingRequest, O: OfflineResponse },
    { name: "DeleteDeadletterQueueData", options: {}, I: DeleteDeadletterQueueDataRequest, O: OfflineResponse },
    { name: "LogOnUser", options: {}, I: LogonUserRequest, O: OfflineResponse },
    { name: "LogOffUser", options: {}, I: LogOffUserRequest, O: OfflineResponse },
    { name: "GetWorkstationName", options: {}, I: GetWorkstationNameRequest, O: GetWorkstationNameResponse }
]);
